14-将OLED显示部分加入程序10,串口发送值（ASCII方式）的同时，OLED显示

13-修改厂家OLED显示程序,以字符串方式显示

12-厂家OLED显示程序

11-读取FDC2214-ACSII显示
读取4路通道值,以ASCII方式发送到串口显示，

10-读取FDC2214-读4路通道值
读取4路通道值，发送到串口显示，每路通道值为4位16进制数，每组值前有前导数值，F0，F1，F2，F3为通道号
FDC2214初始中各参数的含义，请查阅FDC2214的器件手册。

09-读取FDC2214
1、根据器件手册及IIC协议要求，在FDC2214Init()函数中读取MANUFACTURER_ID的值(0x5449)，
验证程序中IIC协议部分是否正确
2、无法的解决问题：
（1）OLED和FDC2214都是IIC协议，基本的IIC操作部分想共用代码，但无法在程序中对不同的器件指定SDA和SCL端口
因为C51不支持位指针。
（2）可能可行的解决方法：硬件共用SDA和SCL端口，程序通过软件中硬件地址位来区分。
因为没有试过一个IIC总线上挂多个设备，所以暂未采用这个方案。
只能后面使用OLED时，重写一遍IIC的协议代码。
..\SYSTEM\IIC.c
..\SYSTEM\IIC.h

08-五向按键(确定单次按键有效)
用与单个按键类似的方法，连续读入８次ＡＤ，如果为同一键值，再连续（不一定紧接着）读入８次未按下，此时确认为按键有效抬起，进行相应操作。

07-五向按键(AD中断判断键值)
根据上例用串口读取出的各按键按下后的AD设定阈值，判断按键
KeyStartStop 0     		0x00
KeyDown  1/2Vcc			0x81
KeyMiddle  2/3Vcc		0xAB-0xAC
KeyRight  3/4Vcc		0xC0-0xC1
KeyLeft  4/5Vcc			0xCE-0xCD
KeyUp    5/6Vcc			0xD6
NoneKey  Vcc 			0xFF
注意：有与单个按键同样的问题，如何才能准确的判断一次按键

	键名			电压值		测量AD值			键值区间
0	KeyStartStop 	0     		0x00		   	0x00-0x40
1	KeyDown  		1/2Vcc		0x81			0x41-0x95	
2	KeyMiddle  		2/3Vcc		0xAB-0xAC		0x96-0xB6
3	KeyRight  		3/4Vcc		0xC0-0xC1		0xB7-0xC7
4	KeyLeft  		4/5Vcc		0xCE-0xCD		0xC8-0xD1
5	KeyUp    		5/6Vcc		0xD6			0xD2-0xEA
6	NoneKey  		Vcc 		0xFF			0xEB-0xFF
手册上提供的方法（STC15F2K60S2手册4.23节）：	每隔10ms左右读一次ADC值，并且保存最后3次的读数，
其变化比较小时再判断键。判断键有效时，允许一定的偏差，比如正负16个字的偏差。
实际采用的方法是：通过测试各按键的ADC值，取中间值为阈值


06-五向按键(AD中断读值)
本例通过整合04例和05例程序，实现6个按键（五向按键和启停键）的AD值连续送串口显示


05-五向按键(STC示例修改1)
本例在范例程序：AD中断方式-C 的基础上修改
对AD通道0，P00取样（P00连接5向按键）
原例中，串口初始化有问题：
T2L = 0xe8;                 //设置波特率重装值


04-按键(定时中断)整理
本例将按前一例子中的按键程序整理成函数调用
注意：myself.c 中，若bit TestKeyLastTime=0，会出现上电时误判有一次按键动作。
因为 若bit TestKeyLastTime=0，if((cJudgeKey==0xFF) && (TestKeyLastTime!=KeyIO)) 这一条件会成立

03-按键(定时中断)
本例在串口用中断实现的基础上，设置定时器0为1ms中断，2ms读一次按键端口，
连续读8次为同一状态时，认为按键稳定。
当按键从按下到抬起稳定后，确定为一次按键结束，进行相应操作。

02-串口(中断方式)
本例保留了按键部分，将串口1通讯修改为中断方式


01-按键(延时去抖)串口(查询方式)
本例用来测试串口编程（查询方式）的有效的按键识别（延时去抖）
一、相关知识：
1.串口的相关寄存器设置
2.IO的模式的设置
3.定时中断

二、讲解过程
1.串口的查询方式，要注意在串口输入时，设计为死循环等待
2.Keil C中，编译时，未用的局部函数和未用的
可以构建个函数，通过在函数中是否引用，编译后查看
Program Size: data 的大小来说明

void tempFunction(void)
{
	unsigned char temp=0;
}
3.其中按键识别是讲解的难点
延时去抖
（1）一般方法，未识别按键抬起
（2）识别按键抬起，未有效去抖
（3）有效识别按键抬起及去抖